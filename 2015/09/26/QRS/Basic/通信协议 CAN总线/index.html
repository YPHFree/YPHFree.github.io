<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>STM32 CAN串行通信协议 | yphfree的学习笔记</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">STM32 CAN串行通信协议</h1><a id="logo" href="/.">yphfree的学习笔记</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">STM32 CAN串行通信协议</h1><div class="post-meta">Sep 26, 2015<span> | </span><span class="category"><a href="/categories/嵌入式开发学习笔记/">嵌入式开发学习笔记</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#CAN-简介"><span class="toc-number">1.</span> <span class="toc-text">CAN 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAN-的报文种类及结构"><span class="toc-number">2.</span> <span class="toc-text">CAN 的报文种类及结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAN-协议特点："><span class="toc-number">3.</span> <span class="toc-text">CAN 协议特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STM32-CAN-控制器"><span class="toc-number">4.</span> <span class="toc-text">STM32 CAN 控制器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STM32-CAN-位时序"><span class="toc-number">5.</span> <span class="toc-text">STM32 CAN 位时序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAN-的初始化配置步骤"><span class="toc-number">6.</span> <span class="toc-text">CAN 的初始化配置步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#打包报文"><span class="toc-number">7.</span> <span class="toc-text">打包报文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#接收报文、编写中断服务函数"><span class="toc-number">8.</span> <span class="toc-text">接收报文、编写中断服务函数</span></a></li></ol></div></div><div class="post-content"><h4 id="CAN-简介"><a href="#CAN-简介" class="headerlink" title="CAN 简介"></a>CAN 简介</h4><p>CAN 是 Controller Area Network 的缩写（以下称为 CAN），是 ISO 国际标准化的串行通信协议,CAN 的高性能和可靠性已被认同，并被广泛地应用于工业自动化、船舶、医疗设备、工业设备等方面。现场总线是当今自动化领域技术发展的热点之一，被誉为自动化领域的计算机局域网。它的出现为分布式控制系统实现各节点之间实时、可靠的数据通信提供了强有力的技术支持。</p>
<p><strong>CAN控制器通过组成总线的2根线（CAN-H和CAN-L）的电位差来确定总线的电平，在任一时刻，总线上有2种电平：显性电平和隐性电平。发送方通过使总线电平发生变化，将消息发送给接收方。</strong></p>
<p>总线上执行逻辑上的线“与”时，显性电平的逻辑值为“0”，隐性电平为“1”。</p>
<p>与 IIC、SPI 等具有时钟信号的通信方式不同，CAN 通信并不是以时钟信号来进行同步的。它只具有 CAN_High 和 CAN_Low 两条信号线，共同构成一组差分信号线，所以CAN 是以差分信号的形式进行通信的。</p>
<h4 id="CAN-的报文种类及结构"><a href="#CAN-的报文种类及结构" class="headerlink" title="CAN 的报文种类及结构"></a>CAN 的报文种类及结构</h4><p>在 SPI 通信中，片选、时钟信号、数据输入及数据输出这四个信号都有单独的信号线。而 CAN 使用的是两条差分信号线，只能表达一个信号。简洁的物理层决定了 CAN 必然要配上一套更复杂的协议。如何用一个信号通道实现同样甚至更强大的功能呢？答案是对数据或操作命令进行打包。</p>
<h4 id="CAN-协议特点："><a href="#CAN-协议特点：" class="headerlink" title="CAN 协议特点："></a>CAN 协议特点：</h4><p><strong>1） 多主控制。</strong> </p>
<p>在总线空闲时，所有单元都可以发送消息（多主控制），而两个以上的单元同时开始发送消息时，根据标识符（ Identifier 以下称为 ID）决定优先级。 ID 并不是表示发送的目的地址，而是表示访问总线的消息的优先级。两个以上的单元同时开始发送消息时，对各消息 ID 的每个位进行逐个仲裁比较。仲裁获胜（被判定为优先级最高）的单元可继续发送消息，仲裁失利的单元则立刻停止发送而进行接收工作。</p>
<p><strong>2） 系统的柔软性。</strong> </p>
<p>与总线相连的单元没有类似于“地址”的信息。因此在总线上增加单元时，连接在总线上的其它单元的软硬件及应用层都不需要改变。</p>
<p><strong>3） 通信速度较快，通信距离远。</strong> </p>
<p>最高 1Mbps（距离小于 40M），最远可达 10KM（速率低于 5Kbps）。</p>
<p><strong>4） 具有错误检测、错误通知和错误恢复功能。</strong></p>
<p>所有单元都可以检测错误（错误检测功能），检测出错误的单元会立即同时通知其他所有单元（错误通知功能），正在发送消息的单元一旦检测出错误，会强制结束当前的发送。强制结束发送的单元会不断反复地重新发送此消息直到成功发送为止（错误恢复功能）。</p>
<p><strong>5） 故障封闭功能。</strong></p>
<p>CAN 可以判断出错误的类型是总线上暂时的数据错误（如外部噪声等）还是持续的数据错误（如单元内部故障、驱动器故障、断线等）。由此功能，当总线上发生持续数据错误时，可将引起此故障的单元从总线上隔离出去。</p>
<p><strong>6） 连接节点多。</strong>    </p>
<p>CAN 总线是可同时连接多个单元的总线。可连接的单元总数理论上是没有限制的。但实际上可连接的单元数受总线上的时间延迟及电气负载的限制。降低通信速度，可连接的单元数增加；提高通信速度，则可连接的单元数减少。正是因为 CAN 协议的这些特点，使得 CAN 特别适合工业过程监控设备的互连，因此，越来越受到工业界的重视，并已公认为最有前途的现场总线之一。</p>
<p>CAN 协议经过 ISO 标准化后有两个标准：ISO11898 标准和 ISO11519-2 标准。其中 ISO11898是针对通信速率为 125Kbps~1Mbps 的高速通信标准，而 ISO11519-2 是针对通信速率为 125Kbps以下的低速通信标准。</p>
<p><strong>显性电平对应逻辑 0， CAN_H 和 CAN_L 之差为 2.5V 左右。</strong><br><strong>隐性电平对应逻辑 1， CAN_H 和 CAN_L 之差为 0V。</strong></p>
<p>在总线上显性电平具有优先权，只要有一个单元输出显性电平，总线上即为显性电平。而隐形电平则具有包容的意味，只有所有的单元都输出隐性电平，总线上才为隐性电平（显性电平比隐性电平更强）。另外，在 CAN 总线的起止端都有一个 120Ω的终端电阻，来做阻抗匹配，以减少回波反射。</p>
<p>CAN 协议是通过以下 5 种类型的帧进行的：</p>
<ul>
<li>数据帧</li>
<li>遥控帧</li>
<li>错误帧</li>
<li>过载帧</li>
<li>帧间隔</li>
</ul>
<p>数据帧和遥控帧有标准格式和扩展格式两种格式。标准格式有 11 个位的标识符ID，扩展格式有 29 个位的 ID。</p>
<table>
<thead>
<tr>
<th>帧类型</th>
<th>帧用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据帧</td>
<td>用于发送单元向接收单元传送数据的帧</td>
</tr>
<tr>
<td>遥控帧</td>
<td>用于接收单元向具有相同 ID 的发送单元请求数据的帧</td>
</tr>
<tr>
<td>错误帧</td>
<td>用于当检测出错误时向其它单元通知错误的帧</td>
</tr>
<tr>
<td>过载帧</td>
<td>用于接收单元通知其尚未做好接收准备的帧</td>
</tr>
<tr>
<td>间隔帧</td>
<td>用于将数据帧及遥控帧与前面的帧分离开来的帧</td>
</tr>
</tbody>
</table>
<p>数据帧一般由 7 个段构成，即：<br>    （ 1） 帧起始。表示数据帧开始的段。<br>    （ 2） 仲裁段。表示该帧优先级的段。<br>    （ 3） 控制段。表示数据的字节数及保留位的段。<br>    （ 4） 数据段。数据的内容，一帧可发送 0~8 个字节的数据。<br>    （ 5） CRC 段。检查帧的传输错误的段。<br>    （ 6） ACK 段。表示确认正常接收的段<br>    （ 7） 帧结束。表示数据帧结束的段。</p>
<p>STM32 自带的是 bxCAN，即基本扩展 CAN。它支持 CAN 协议 2.0A 和 2.0B。它的设<br>计目标是，以最小的 CPU 负荷来高效处理大量收到的报文。它也支持报文发送的优先级要求(优<br>先级特性可软件配置)。对于安全紧要的应用， bxCAN 提供所有支持时间触发通信模式所需的<br>硬件功能。   </p>
<p>STM32 的 bxCAN 的主要特点有：</p>
<ul>
<li>支持 CAN 协议 2.0A 和 2.0B 主动模式</li>
<li>波特率最高达 1Mbps</li>
<li>支持时间触发通信</li>
<li>具有 3 个发送邮箱</li>
<li>具有 3 级深度的 2 个接收 FIFO</li>
<li>可变的过滤器组（最多 28 个）</li>
</ul>
<p>同步<br>由于 CAN 没有时钟信号线，而且它的报文中并没有包含用于同步的标志，所以要使<br>用<strong>位同步</strong>的方式来确保通信时序，以及对总线的电平进行正确采样。</p>
<h4 id="STM32-CAN-控制器"><a href="#STM32-CAN-控制器" class="headerlink" title="STM32 CAN 控制器"></a>STM32 CAN 控制器</h4><p>STM32 自带的是 bxCAN，即基本扩展 CAN。它支持 CAN 协议 2.0A 和 2.0B。它的设<br>计目标是，以最小的 CPU 负荷来高效处理大量收到的报文。它也支持报文发送的优先级要求(优<br>先级特性可软件配置)。对于安全紧要的应用， bxCAN 提供所有支持时间触发通信模式所需的<br>硬件功能。<br>STM32 的 bxCAN 的主要特点有：</p>
<ul>
<li>支持 CAN 协议 2.0A 和 2.0B 主动模式</li>
<li>波特率最高达 1Mbps</li>
<li>支持时间触发通信</li>
<li>具有 3 个发送邮箱</li>
<li>具有 3 级深度的 2 个接收 FIFO</li>
<li>可变的过滤器组（最多 28 个）</li>
</ul>
<p>STM32 的标识符过滤是一个比较复杂的东东，它的存在减少了 CPU 处理 CAN 通信的开销。STM32 的过滤器组最多有 28 个（互联型），但是 STM32F103ZET6 只有 14 个（增强型），每个滤波器组 x 由2个 32 位寄存器， CAN_FxR1 和 CAN_FxR2 组成。</p>
<p>STM32 每个过滤器组的位宽都可以独立配置，以满足应用程序的不同需求。根据位宽的不<br>同，每个过滤器组可提供：</p>
<ul>
<li>1 个 32 位过滤器，包括： STDID[10:0]、 EXTID[17:0]、 IDE 和 RTR 位</li>
<li>2 个 16 位过滤器，包括： STDID[10:0]、 IDE、 RTR 和 EXTID[17:15]位<br>此外过滤器可配置为，屏蔽位模式和标识符列表模式</li>
</ul>
<p><strong>Tx Mailboxes(发送邮箱)</strong><br>STM32 的 CAN 中共有 3 个发送邮箱供软件来发送报文。发送调度器根据优先级决定<br>哪个邮箱的报文先被发送。</p>
<p><strong>Accepttance Filters( 接收过滤器 )</strong><br>STM32 的 CAN 中共有 14 个位宽可变/可配置的标识符过滤器组，软件通过对它们编<br>程，从而在 CAN 收到的报文中选择它需要的报文，而把其它报文丢弃掉。</p>
<p><strong>Receive FIFO( 接收 FIFO )</strong><br>STM32 的 CAN 中共有 2 个接收 FIFO，每个 FIFO 都可以存放 3 个完整的报文。它们<br>完全由硬件来管理。</p>
<p><strong>CAN 的工作就是围绕这三部分展开的</strong></p>
<h4 id="STM32-CAN-位时序"><a href="#STM32-CAN-位时序" class="headerlink" title="STM32 CAN 位时序"></a>STM32 CAN 位时序</h4><p>CAN 波特率的计算公式，我们只需要知道 BS1 和 BS2 的设置，以及 APB1<br>的时钟频率（一般为 36Mhz），就可以方便的计算出波特率。比如设置 TS1=6、 TS2=7 和 BRP=4，<br>在 APB1 频率为 36Mhz 的条件下，即可得到 CAN 通信的波特率=36000/[(7+8+1) * 5]=450Kbps。</p>
<p><strong>CAN 的主控制寄存器 CAN_MCR</strong></p>
<h4 id="CAN-的初始化配置步骤"><a href="#CAN-的初始化配置步骤" class="headerlink" title="CAN 的初始化配置步骤"></a>CAN 的初始化配置步骤</h4><p>CAN 相关的固件库函数和定义分布在文件 stm32f10x_can.c 和头文件 stm32f10x_can.h 文件中。</p>
<p><strong>1）配置相关引脚的复用功能，使能  CAN 时钟</strong></p>
<p><strong>2）设置 CAN 工作模式及波特率等。</strong><br>这一步通过先设置 CAN_MCR 寄存器的 INRQ 位，让 CAN 进入初始化模式，然后设置<br>CAN_MCR 的其他相关控制位。再通过 CAN_BTR 设置波特率和工作模式（正常模式/环回模式）<br>等信息。 最后设置 INRQ 为 0，退出初始化模式。</p>
<p>库函数中，提供了函数 CAN_Init()用来初始化 CAN 的工作模式以及波特率， CAN_Init()函数体中，在初始化之前，会设置 CAN_MCR 寄存器的 INRQ 为 1 让其进入初始化模式，然后初始化 CAN_MCR 寄存器和 CRN_BTR 寄存器之后，会设置 CAN_MCR 寄存器的 INRQ 为 0让其退出初始化模式。所以我们在调用这个函数的前后不需要再进行初始化模式设置。</p>
<p>初始化实例为：  </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CAN_InitStructure</span>.CAN_TTCM=DISABLE; <span class="comment">//非时间触发通信模式</span></span><br><span class="line"><span class="built_in">CAN_InitStructure</span>.CAN_ABOM=DISABLE; <span class="comment">//软件自动离线管理</span></span><br><span class="line"><span class="built_in">CAN_InitStructure</span>.CAN_AWUM=DISABLE; <span class="comment">//睡眠模式通过软件唤醒</span></span><br><span class="line"><span class="built_in">CAN_InitStructure</span>.CAN_NART=ENABLE; <span class="comment">//禁止报文自动传送</span></span><br><span class="line"><span class="built_in">CAN_InitStructure</span>.CAN_RFLM=DISABLE; <span class="comment">//报文不锁定,新的覆盖旧的</span></span><br><span class="line"><span class="built_in">CAN_InitStructure</span>.CAN_TXFP=DISABLE; <span class="comment">//优先级由报文标识符决定</span></span><br><span class="line"><span class="built_in">CAN_InitStructure</span>.CAN_Mode= <span class="built_in">CAN_Mode_LoopBack</span>; <span class="comment">//模式设置： 1,回环模式;</span></span><br><span class="line"><span class="comment">//设置波特率</span></span><br><span class="line"><span class="built_in">CAN_InitStructure</span>.CAN_SJW=<span class="built_in">CAN_SJW_1tq</span>;<span class="comment">//重新同步跳跃宽度为个时间单位</span></span><br><span class="line"><span class="built_in">CAN_InitStructure</span>.CAN_BS1=<span class="built_in">CAN_BS1_8tq</span>; <span class="comment">//时间段 1 占用 8 个时间单位</span></span><br><span class="line"><span class="built_in">CAN_InitStructure</span>.CAN_BS2=<span class="built_in">CAN_BS2_7tq</span>;<span class="comment">//时间段 2 占用 7 个时间单位</span></span><br><span class="line"><span class="built_in">CAN_InitStructure</span>.CAN_Prescaler=<span class="number">5</span>; <span class="comment">//分频系数(Fdiv)</span></span><br><span class="line"><span class="built_in">CAN_Init</span>(<span class="built_in">CAN1</span>, &amp;<span class="built_in">CAN_InitStructure</span>); <span class="comment">// 初始化 CAN1</span></span><br></pre></td></tr></table></figure>
<p><strong>3）设置滤波器。</strong><br>先设置 CAN_FMR的 FINIT 位，让过滤器组工作在初始化模式下，然后设置滤波器组 0 的工作模式以及标识符 ID<br>和屏蔽位。最后激活滤波器，并退出滤波器初始化模式。</p>
<p>过滤器初始化参考实例代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CAN_FilterInitStructure</span>.CAN_FilterNumber=<span class="number">0</span>; <span class="comment">//过滤器 0</span></span><br><span class="line"><span class="built_in">CAN_FilterInitStructure</span>.CAN_FilterMode=<span class="built_in">CAN_FilterMode_IdMask</span>;</span><br><span class="line"><span class="built_in">CAN_FilterInitStructure</span>.CAN_FilterScale=<span class="built_in">CAN_FilterScale_32bit</span>; <span class="comment">//32 位</span></span><br><span class="line"><span class="built_in">CAN_FilterInitStructure</span>.CAN_FilterIdHigh=<span class="number">0x0000</span>;<span class="comment">////32 位 ID</span></span><br><span class="line"><span class="built_in">CAN_FilterInitStructure</span>.CAN_FilterIdLow=<span class="number">0x0000</span>;</span><br><span class="line"><span class="built_in">CAN_FilterInitStructure</span>.CAN_FilterMaskIdHigh=<span class="number">0x0000</span>;<span class="comment">//32 位 MASK</span></span><br><span class="line"><span class="built_in">CAN_FilterInitStructure</span>.CAN_FilterMaskIdLow=<span class="number">0x0000</span>;</span><br><span class="line"><span class="built_in">CAN_FilterInitStructure</span>.CAN_FilterFIFOAssignment=<span class="built_in">CAN_Filter_FIFO0</span>;<span class="comment">// FIFO0</span></span><br><span class="line"><span class="built_in">CAN_FilterInitStructure</span>.CAN_FilterActivation=ENABLE; <span class="comment">//激活过滤器 0</span></span><br><span class="line"><span class="built_in">CAN_FilterInit</span>(&amp;<span class="built_in">CAN_FilterInitStructure</span>);<span class="comment">//滤波器初始化</span></span><br></pre></td></tr></table></figure></p>
<p>至此， CAN 就可以开始正常工作了。如果用到中断，就还需要进行中断相关的配置，</p>
<p><strong>4）发送接受消息</strong></p>
<p>在初始化 CAN 相关参数以及过滤器之后，接下来就是发送和接收消息了。 库函数中提供<br>了发送和接受消息的函数。       </p>
<p>发送消息的函数是：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint8_t <span class="built_in">CAN_Transmit</span>(<span class="built_in">CAN_TypeDef</span>* <span class="built_in">CANx</span>, CanTxMsg* TxMessage)；</span><br></pre></td></tr></table></figure></p>
<p>第一个参数是 CAN 标号，我们使用 CAN1。第二个参数是相关消息结构<br>体 CanTxMsg 指针类型， CanTxMsg 结构体的成员变量用来设置标准标识符，扩展标示符，消<br>息类型和消息帧长度等信息。</p>
<p>接受消息的函数是：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">CAN_Receive</span>(<span class="built_in">CAN_TypeDef</span>* <span class="built_in">CANx</span>, uint8_t FIFONumber, CanRxMsg* RxMessage;</span><br></pre></td></tr></table></figure></p>
<p>前面两个参数也比较好理解， CAN 标号和 FIFO 号。 第二个参数 RxMessage 是用来存放接受到<br>的消息信息。</p>
<p>结构体 CanRxMsg 和结构体 CanTxMsg 比较接近，分别用来定义发送消息和描述接受消息，</p>
<p><strong>5） CAN 状态获取</strong><br>对于 CAN 发送消息的状态，挂起消息数目等等之类的传输状态信息，库函数提供了一些列的函数，包括 CAN_TransmitStatus()函数， CAN_MessagePending()函数， CAN_GetFlagStatus()函数等等，大家可以根据需要来调用。</p>
<p>CAN 的中断由发送中断、接收 FIFO 中断和错误中断构成。发送中断由三个发送邮箱<br>任意一个为空的事件构成。接收 FIFO 中断分为 FIFO0 和 FIFO1 的中断，接收 FIFO 收到<br>新的报文或报文溢出的事件可以引起中断。本实验中使用的 RX0 中断通道即为 FIFO0 中<br>断通道，当 FIFO0 收到新报文时，引起中断，我们就在相应的中断服务函数读取这个新报<br>文</p>
<h4 id="打包报文"><a href="#打包报文" class="headerlink" title="打包报文"></a>打包报文</h4><p>配置好 CAN 接口后，我们就可以复用它来发送数据了。利用 CAN 发送数据，要先把数据打包成完整的 CAN 报文格式。</p>
<p>void CAN_SetMsg(void)<br>{<br>    //TxMessage.StdId=0x00;<br>    TxMessage.ExtId=0x1314; //使用的扩展 ID<br>    TxMessage.IDE=CAN_ID_EXT; //扩展模式<br>    TxMessage.RTR=CAN_RTR_DATA; //发送的是数据<br>    TxMessage.DLC=2; //数据长度为 2 字节<br>    TxMessage.Data[0]=0xAB;<br>    TxMessage.Data[1]=0xCD;<br>}</p>
<p>函数使用的结构体变量 TxMessage 在 main 文件以全局变量的形式定义，结构体变量 TxMessage 和 RxMessage.<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CanTxMsg TxMessage; <span class="comment">// 发送缓冲区</span></span><br><span class="line">CanRxMsg RxMessage; <span class="comment">// 接收缓冲区</span></span><br></pre></td></tr></table></figure></p>
<p>TxMessage 的类型为 CanTxMsg，而接收报文时，我们使用 CanRxMsg 类型。它们都是由库文件定义的结构体类型。</p>
<p><strong>报文打包函数</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void CAN_SetMsg(void)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//TxMessage.StdId=0x00;</span></span><br><span class="line">	TxMessage.ExtId=<span class="number">0x1314</span>; <span class="comment">//使用的扩展 ID</span></span><br><span class="line">	TxMessage.IDE=CAN_ID_EXT; <span class="comment">//扩展模式</span></span><br><span class="line">	TxMessage.RTR=CAN_RTR_DATA; <span class="comment">//发送的是数据</span></span><br><span class="line">	TxMessage.DLC=<span class="number">2</span>; <span class="comment">//数据长度为 2 字节</span></span><br><span class="line">	TxMessage.Data[<span class="number">0</span>]=<span class="number">0xDC</span>;</span><br><span class="line">	TxMessage.Data[<span class="number">1</span>]=<span class="number">0xBA</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>接收报文结构体 CanRxMsg</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> StdId; <span class="comment">/* 接收报文的标准 ID */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> ExtId; <span class="comment">/* 接收报文的扩展 ID */</span></span><br><span class="line">	<span class="keyword">uint8_t</span> IDE; <span class="comment">/* 报文的 IDE 位 */</span></span><br><span class="line">	<span class="keyword">uint8_t</span> RTR; <span class="comment">/* 报文的 RTR 位 */</span></span><br><span class="line">	<span class="keyword">uint8_t</span> DLC; <span class="comment">/* 报文的 DLC 段 */</span></span><br><span class="line">	<span class="keyword">uint8_t</span> Data[<span class="number">8</span>]; <span class="comment">/* 报文的数据段 */</span></span><br><span class="line">	<span class="keyword">uint8_t</span> FMI; <span class="comment">/* 过滤器匹配序号 */</span></span><br><span class="line"></span><br><span class="line">&#125; CanRxMsg;</span><br></pre></td></tr></table></figure></p>
<h4 id="接收报文、编写中断服务函数"><a href="#接收报文、编写中断服务函数" class="headerlink" title="接收报文、编写中断服务函数"></a>接收报文、编写中断服务函数</h4><p>从机中断服务函数<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void USB_LP_CAN1_RX0_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">	CAN_Receive(CAN1, CAN_FIFO0, &amp;RxMessage);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 比较是否是发送的数据和 ID */</span></span><br><span class="line"></span><br><span class="line">	if ((RxMessage.ExtId==<span class="number">0x1314</span>) &amp;&amp; (RxMessage.IDE==CAN_ID_EXT)&amp;&amp; (RxMessage.DLC==<span class="number">2</span>) \</span><br><span class="line">		 &amp;&amp;((RxMessage.Data[<span class="number">1</span>]|RxMessage.Data[<span class="number">0</span>]&lt;&lt;<span class="number">8</span>)==<span class="number">0xABCD</span>)) </span><br><span class="line">	&#123;</span><br><span class="line">		flag = <span class="number">0</span>; <span class="comment">//接收成功</span></span><br><span class="line">	&#125; </span><br><span class="line">	else </span><br><span class="line">	&#123;</span><br><span class="line">	     flag = <span class="number">0xff</span>; <span class="comment">//接收失败</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在中断服务函数中，我们调用了库函数 CAN_Receive() 把 FIFO0 的报文读取到 main<br>文件的 CanRxMsg 类型全局变量 RxMessage 中。</p>
<p>使用 CAN_Receive() 函数接收了报文后，我们使用 if 语句判断接收到的报文的 ID 信息、IDE 位、DLC 位及数据段是否等于 0xABCD，若接收到的报文与我们主机预定发送的报文一样，则把 fl ag 位置“0”，退出中断服务函数。</p>
</div><div class="tags"><a href="/tags/通信协议/">通信协议</a></div><div class="post-nav"><a class="pre" href="/2015/09/26/QRS/Basic/通信协议 STM32 USB/">通信协议 STM32 USB</a><a class="next" href="/2015/09/26/QRS/Basic/通信协议 STM32 UART串行总线/">STM32 USART串行总线</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android学习笔记/">Android学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CC2540/">CC2540</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C语言学习/">C语言学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/FreeRTOS/">FreeRTOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Numpy学习笔记/">Numpy学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/PyQt5快速开发与实战/">PyQt5快速开发与实战</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python学习笔记/">Python学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/S3C2440学习笔记/">S3C2440学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/STM32学习笔记/">STM32学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/单片机/">单片机</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/嵌入式开发学习笔记/">嵌入式开发学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法之美学习笔记/">数据结构与算法之美学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/汽车总线/">汽车总线</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/汽车电子学习笔记/">汽车电子学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/汽车电子开发学习笔记/">汽车电子开发学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/硬件学习笔记/">硬件学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/统一诊断服务UDS/">统一诊断服务UDS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件开发/">软件开发</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/通信协议/" style="font-size: 15px;">通信协议</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/硬件基础/" style="font-size: 15px;">硬件基础</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Python3/" style="font-size: 15px;">Python3</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/STM32基础/" style="font-size: 15px;">STM32基础</a> <a href="/tags/PyQt5/" style="font-size: 15px;">PyQt5</a> <a href="/tags/嵌入式基础知识/" style="font-size: 15px;">嵌入式基础知识</a> <a href="/tags/嵌入式基础知识-硬件基础知识/" style="font-size: 15px;">嵌入式基础知识 硬件基础知识</a> <a href="/tags/嵌入式基础知识-通信协议/" style="font-size: 15px;">嵌入式基础知识 通信协议</a> <a href="/tags/锂电池/" style="font-size: 15px;">锂电池</a> <a href="/tags/嵌入式基础知识-通信协议/" style="font-size: 15px;">嵌入式基础知识, 通信协议</a> <a href="/tags/Python-Numpy/" style="font-size: 15px;">Python Numpy</a> <a href="/tags/S3C2440/" style="font-size: 15px;">S3C2440</a> <a href="/tags/C51/" style="font-size: 15px;">C51</a> <a href="/tags/STM32项目/" style="font-size: 15px;">STM32项目</a> <a href="/tags/CC2540/" style="font-size: 15px;">CC2540</a> <a href="/tags/FreeRTOS/" style="font-size: 15px;">FreeRTOS</a> <a href="/tags/有限状态机/" style="font-size: 15px;">有限状态机</a> <a href="/tags/汽车电子/" style="font-size: 15px;">汽车电子</a> <a href="/tags/LIN/" style="font-size: 15px;">LIN</a> <a href="/tags/统一诊断服务UDS/" style="font-size: 15px;">统一诊断服务UDS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/01/QRS/S3C2440/解析S3C2440第一个C程序的内部机制/">解析S3C2440第一个C程序的内部机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/23/SoftWare_skills/Finite_State_Machine/用状态机原理进行软件设计——FSM概念/">用状态机原理进行软件设计——FSM概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/23/SoftWare_skills/Finite_State_Machine/状态机/">有限状态机,</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/14/QRS/AutomotiveSoftware/Diagnostic/统一诊断服务/">汽车控制器(ECU)统一诊断服务基础知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/04/QRS/AutomotiveSoftware/LIN/LIN总线诊断的实现/">LIN学习——LIN总线诊断的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/04/QRS/AutomotiveSoftware/Diagnostic/汽车ECU诊断基本概念/">汽车ECU诊断基本概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/03/QRS/AutomotiveSoftware/Diagnostic/CAN诊断基础知识/">CAN诊断基础知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/20/QRS/AutomotiveSoftware/LIN/LIN学习——LIN应用层/">QRS/AutomotiveSoftware/LIN/LIN学习——LIN应用层</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/20/QRS/AutomotiveSoftware/LIN/LIN学习——工作流/">LIN学习——工作流</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/19/QRS/AutomotiveSoftware/LIN/LIN学习——LIN描述文件/">QRS/AutomotiveSoftware/LIN/LIN学习——LIN描述文件</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">yphfree的学习笔记.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>