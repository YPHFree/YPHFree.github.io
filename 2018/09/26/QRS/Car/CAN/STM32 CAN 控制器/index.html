<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>STM32 CAN 控制器 | yphfree的学习笔记</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">STM32 CAN 控制器</h1><a id="logo" href="/.">yphfree的学习笔记</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">STM32 CAN 控制器</h1><div class="post-meta">Sep 26, 2018<span> | </span><span class="category"><a href="/categories/嵌入式开发学习笔记/">嵌入式开发学习笔记</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#STM32-的-CAN-特性及架构"><span class="toc-number">1.</span> <span class="toc-text">STM32 的 CAN 特性及架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#STM32-CAN-控制器"><span class="toc-number">1.1.</span> <span class="toc-text">STM32 CAN 控制器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAN-架构"><span class="toc-number">1.2.</span> <span class="toc-text">CAN 架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#发送流程"><span class="toc-number">1.3.</span> <span class="toc-text">发送流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAN-接收流程为："><span class="toc-number">1.4.</span> <span class="toc-text">CAN 接收流程为：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAN-的位时序"><span class="toc-number">1.5.</span> <span class="toc-text">CAN 的位时序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STM32-CAN-位时序特性"><span class="toc-number">1.6.</span> <span class="toc-text">STM32 CAN 位时序特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAN-的初始化配置步骤"><span class="toc-number">1.7.</span> <span class="toc-text">CAN 的初始化配置步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#打包报文"><span class="toc-number">1.8.</span> <span class="toc-text">打包报文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#接收报文、编写中断服务函数"><span class="toc-number">1.9.</span> <span class="toc-text">接收报文、编写中断服务函数</span></a></li></ol></li></ol></div></div><div class="post-content"><h3 id="STM32-的-CAN-特性及架构"><a href="#STM32-的-CAN-特性及架构" class="headerlink" title="STM32 的 CAN 特性及架构"></a>STM32 的 CAN 特性及架构</h3><h4 id="STM32-CAN-控制器"><a href="#STM32-CAN-控制器" class="headerlink" title="STM32 CAN 控制器"></a>STM32 CAN 控制器</h4><p>STM32 自带的是 bxCAN，即基本扩展 CAN。它支持 CAN 协议 2.0A 和 2.0B。它的设计目标是，以最小的 CPU 负荷来高效处理大量收到的报文。它也支持报文发送的优先级要求(优先级特性可软件配置)。对于安全紧要的应用， bxCAN 提供所有支持时间触发通信模式所需的硬件功能。</p>
<p>STM32 的 bxCAN 的主要特点有：</p>
<ul>
<li>支持 CAN 协议 2.0A 和 2.0B 主动模式</li>
<li>波特率最高达 1Mbps</li>
<li>支持时间触发通信</li>
<li>具有 3 个发送邮箱</li>
<li>具有 3 级深度的 2 个接收 FIFO</li>
<li>可变的过滤器组（最多 28 个）</li>
</ul>
<p>STM32 的标识符过滤是一个比较复杂的东东，它的存在减少了 CPU 处理 CAN 通信的开销。STM32 的过滤器组最多有 28 个（互联型），但是 STM32F103ZET6 只有 14 个（增强型），每个滤波器组 x 由2个 32 位寄存器， CAN_FxR1 和 CAN_FxR2 组成。</p>
<p>STM32 每个过滤器组的位宽都可以独立配置，以满足应用程序的不同需求。根据位宽的不<br>同，每个过滤器组可提供：</p>
<ul>
<li>1 个 32 位过滤器，包括： STDID[10:0]、 EXTID[17:0]、 IDE 和 RTR 位</li>
<li>2 个 16 位过滤器，包括： STDID[10:0]、 IDE、 RTR 和 EXTID[17:15]位<br>此外过滤器可配置为，屏蔽位模式和标识符列表模式</li>
</ul>
<p>为了过滤出一组标识符，应该设置过滤器组工作在屏蔽位模式。<br>为了过滤出一个标识符，应该设置过滤器组工作在标识符列表模式。        </p>
<h4 id="CAN-架构"><a href="#CAN-架构" class="headerlink" title="CAN 架构"></a>CAN 架构</h4><p><strong>Tx Mailboxes(发送邮箱)</strong><br>STM32 的 CAN 中共有 3 个发送邮箱供软件来发送报文。发送调度器根据优先级决定<br>哪个邮箱的报文先被发送。</p>
<p><strong>Accepttance Filters( 接收过滤器 )</strong><br>STM32 的 CAN 中共有 14 个位宽可变/可配置的标识符过滤器组，软件通过对它们编<br>程，从而在 CAN 收到的报文中选择它需要的报文，而把其它报文丢弃掉。</p>
<p><strong>Receive FIFO( 接收 FIFO )</strong><br>STM32 的 CAN 中共有 2 个接收 FIFO，每个 FIFO 都可以存放 3 个完整的报文。它们<br>完全由硬件来管理。</p>
<p>CAN 的工作就是围绕这三部分展开的</p>
<h4 id="发送流程"><a href="#发送流程" class="headerlink" title="发送流程"></a>发送流程</h4><p>CAN 发送流程为：程序选择 1 个空置的邮箱（ TME=1）–&gt; 设置标识符（ ID），数据长度和发送数据–&gt;设置 CAN_TIxR 的 TXRQ 位为 1，请求发送–&gt; 邮箱挂号（等待成为最高优先级） –&gt; 预定发送（等待总线空闲）–&gt; 发送 –&gt; 邮箱空置。</p>
<h4 id="CAN-接收流程为："><a href="#CAN-接收流程为：" class="headerlink" title="CAN 接收流程为："></a>CAN 接收流程为：</h4><p>FIFO 空 –&gt; 收到有效报文 –&gt; 挂号_1（存入 FIFO 的一个邮箱，这个由硬件<br>控制，我们不需要理会） –&gt;收到有效报文–&gt; 挂号_2 –&gt;收到有效报文 –&gt;挂号_3–&gt;收到有效报文<br>溢出。</p>
<h4 id="CAN-的位时序"><a href="#CAN-的位时序" class="headerlink" title="CAN 的位时序"></a>CAN 的位时序</h4><p>由发送单元在非同步的情况下发送的每秒钟的位数称为位速率。一个位可分为 4 段。</p>
<ul>
<li>同步段（ SS）</li>
<li>传播时间段（ PTS）</li>
<li>相位缓冲段 1（ PBS1）</li>
<li>相位缓冲段 2（ PBS2）<br>这些段又由可称为 Time Quantum（以下称为 Tq）的最小时间单位构成。</li>
</ul>
<p>1 位分为 4 个段，每个段又由若干个 Tq 构成，这称为位时序。1 位由多少个 Tq 构成、每个段又由多少个 Tq 构成等，可以任意设定位时序。通过设定位时序，多个单元可同时采样，也可任意设定采样点。</p>
<p>采样点，是指读取总线电平，并将读到的电平作为位值的点。位置在 PBS1 结束处。根据这个位时序，我们就可以计算 CAN 通信的波特率了。</p>
<p><strong>在总线空闲态，最先开始发送消息的单元获得发送权。当多个单元同时开始发送时，各发送单元从仲裁段的第一位开始进行仲裁。连续输出显性电平最多的单元可继续发送。</strong></p>
<hr>
<h4 id="STM32-CAN-位时序特性"><a href="#STM32-CAN-位时序特性" class="headerlink" title="STM32 CAN 位时序特性"></a>STM32 CAN 位时序特性</h4><p>STM32 把传播时间段和相位缓冲段 1（ STM32 称之为时间段 1）合并了，所以 STM32 的 CAN 一个位只有 3 段：同步段（ SYNC_SEG）、时间段 1（ BS1）和时间段2（ BS2）。 STM32 的 BS1 段可以设置为 1~16 个时间单元，刚好等于我们上面介绍的传播时间段和相位缓冲段 1 之和。 </p>
<p>CAN 波特率的计算公式，我们只需要知道 BS1 和 BS2 的设置，以及 APB1<br>的时钟频率（一般为 36Mhz），就可以方便的计算出波特率。比如设置 TS1=6、 TS2=7 和 BRP=4，<br>在 APB1 频率为 36Mhz 的条件下，即可得到 CAN 通信的波特率=36000/[(7+8+1) * 5]=450Kbps。</p>
<p><strong>CAN 的主控制寄存器 CAN_MCR</strong></p>
<h4 id="CAN-的初始化配置步骤"><a href="#CAN-的初始化配置步骤" class="headerlink" title="CAN 的初始化配置步骤"></a>CAN 的初始化配置步骤</h4><p>CAN 相关的固件库函数和定义分布在文件 stm32f10x_can.c 和头文件 stm32f10x_can.h 文件中。</p>
<p><strong>1）配置相关引脚的复用功能，使能  CAN 时钟</strong></p>
<p><strong>2）设置 CAN 工作模式及波特率等。</strong><br>这一步通过先设置 CAN_MCR 寄存器的 INRQ 位，让 CAN 进入初始化模式，然后设置<br>CAN_MCR 的其他相关控制位。再通过 CAN_BTR 设置波特率和工作模式（正常模式/环回模式）<br>等信息。 最后设置 INRQ 为 0，退出初始化模式。</p>
<p>库函数中，提供了函数 CAN_Init()用来初始化 CAN 的工作模式以及波特率， CAN_Init()函数体中，在初始化之前，会设置 CAN_MCR 寄存器的 INRQ 为 1 让其进入初始化模式，然后初始化 CAN_MCR 寄存器和 CRN_BTR 寄存器之后，会设置 CAN_MCR 寄存器的 INRQ 为 0让其退出初始化模式。所以我们在调用这个函数的前后不需要再进行初始化模式设置。</p>
<p>初始化实例为：  </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CAN_InitStructure</span>.CAN_TTCM=DISABLE; <span class="comment">//非时间触发通信模式</span></span><br><span class="line"><span class="built_in">CAN_InitStructure</span>.CAN_ABOM=DISABLE; <span class="comment">//软件自动离线管理</span></span><br><span class="line"><span class="built_in">CAN_InitStructure</span>.CAN_AWUM=DISABLE; <span class="comment">//睡眠模式通过软件唤醒</span></span><br><span class="line"><span class="built_in">CAN_InitStructure</span>.CAN_NART=ENABLE; <span class="comment">//禁止报文自动传送</span></span><br><span class="line"><span class="built_in">CAN_InitStructure</span>.CAN_RFLM=DISABLE; <span class="comment">//报文不锁定,新的覆盖旧的</span></span><br><span class="line"><span class="built_in">CAN_InitStructure</span>.CAN_TXFP=DISABLE; <span class="comment">//优先级由报文标识符决定</span></span><br><span class="line"><span class="built_in">CAN_InitStructure</span>.CAN_Mode= <span class="built_in">CAN_Mode_LoopBack</span>; <span class="comment">//模式设置： 1,回环模式;</span></span><br><span class="line"><span class="comment">//设置波特率</span></span><br><span class="line"><span class="built_in">CAN_InitStructure</span>.CAN_SJW=<span class="built_in">CAN_SJW_1tq</span>;<span class="comment">//重新同步跳跃宽度为个时间单位</span></span><br><span class="line"><span class="built_in">CAN_InitStructure</span>.CAN_BS1=<span class="built_in">CAN_BS1_8tq</span>; <span class="comment">//时间段 1 占用 8 个时间单位</span></span><br><span class="line"><span class="built_in">CAN_InitStructure</span>.CAN_BS2=<span class="built_in">CAN_BS2_7tq</span>;<span class="comment">//时间段 2 占用 7 个时间单位</span></span><br><span class="line"><span class="built_in">CAN_InitStructure</span>.CAN_Prescaler=<span class="number">5</span>; <span class="comment">//分频系数(Fdiv)</span></span><br><span class="line"><span class="built_in">CAN_Init</span>(<span class="built_in">CAN1</span>, &amp;<span class="built_in">CAN_InitStructure</span>); <span class="comment">// 初始化 CAN1</span></span><br></pre></td></tr></table></figure>
<p><strong>3）设置滤波器。</strong><br>先设置 CAN_FMR的 FINIT 位，让过滤器组工作在初始化模式下，然后设置滤波器组 0 的工作模式以及标识符 ID<br>和屏蔽位。最后激活滤波器，并退出滤波器初始化模式。</p>
<p>过滤器初始化参考实例代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CAN_FilterInitStructure</span>.CAN_FilterNumber=<span class="number">0</span>; <span class="comment">//过滤器 0</span></span><br><span class="line"><span class="built_in">CAN_FilterInitStructure</span>.CAN_FilterMode=<span class="built_in">CAN_FilterMode_IdMask</span>;</span><br><span class="line"><span class="built_in">CAN_FilterInitStructure</span>.CAN_FilterScale=<span class="built_in">CAN_FilterScale_32bit</span>; <span class="comment">//32 位</span></span><br><span class="line"><span class="built_in">CAN_FilterInitStructure</span>.CAN_FilterIdHigh=<span class="number">0x0000</span>;<span class="comment">////32 位 ID</span></span><br><span class="line"><span class="built_in">CAN_FilterInitStructure</span>.CAN_FilterIdLow=<span class="number">0x0000</span>;</span><br><span class="line"><span class="built_in">CAN_FilterInitStructure</span>.CAN_FilterMaskIdHigh=<span class="number">0x0000</span>;<span class="comment">//32 位 MASK</span></span><br><span class="line"><span class="built_in">CAN_FilterInitStructure</span>.CAN_FilterMaskIdLow=<span class="number">0x0000</span>;</span><br><span class="line"><span class="built_in">CAN_FilterInitStructure</span>.CAN_FilterFIFOAssignment=<span class="built_in">CAN_Filter_FIFO0</span>;<span class="comment">// FIFO0</span></span><br><span class="line"><span class="built_in">CAN_FilterInitStructure</span>.CAN_FilterActivation=ENABLE; <span class="comment">//激活过滤器 0</span></span><br><span class="line"><span class="built_in">CAN_FilterInit</span>(&amp;<span class="built_in">CAN_FilterInitStructure</span>);<span class="comment">//滤波器初始化</span></span><br></pre></td></tr></table></figure></p>
<p>至此， CAN 就可以开始正常工作了。如果用到中断，就还需要进行中断相关的配置，</p>
<p><strong>4）发送接受消息</strong></p>
<p>在初始化 CAN 相关参数以及过滤器之后，接下来就是发送和接收消息了。 库函数中提供<br>了发送和接受消息的函数。       </p>
<p>发送消息的函数是：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint8_t <span class="built_in">CAN_Transmit</span>(<span class="built_in">CAN_TypeDef</span>* <span class="built_in">CANx</span>, CanTxMsg* TxMessage)；</span><br></pre></td></tr></table></figure></p>
<p>第一个参数是 CAN 标号，我们使用 CAN1。第二个参数是相关消息结构<br>体 CanTxMsg 指针类型， CanTxMsg 结构体的成员变量用来设置标准标识符，扩展标示符，消<br>息类型和消息帧长度等信息。</p>
<p>接受消息的函数是：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">CAN_Receive</span>(<span class="built_in">CAN_TypeDef</span>* <span class="built_in">CANx</span>, uint8_t FIFONumber, CanRxMsg* RxMessage;</span><br></pre></td></tr></table></figure></p>
<p>前面两个参数也比较好理解， CAN 标号和 FIFO 号。 第二个参数 RxMessage 是用来存放接受到<br>的消息信息。</p>
<p>结构体 CanRxMsg 和结构体 CanTxMsg 比较接近，分别用来定义发送消息和描述接受消息，</p>
<p><strong>5） CAN 状态获取</strong><br>对于 CAN 发送消息的状态，挂起消息数目等等之类的传输状态信息，库函数提供了一些列的函数，包括 CAN_TransmitStatus()函数， CAN_MessagePending()函数， CAN_GetFlagStatus()函数等等，大家可以根据需要来调用。</p>
<p>CAN 的中断由发送中断、接收 FIFO 中断和错误中断构成。发送中断由三个发送邮箱<br>任意一个为空的事件构成。接收 FIFO 中断分为 FIFO0 和 FIFO1 的中断，接收 FIFO 收到<br>新的报文或报文溢出的事件可以引起中断。本实验中使用的 RX0 中断通道即为 FIFO0 中<br>断通道，当 FIFO0 收到新报文时，引起中断，我们就在相应的中断服务函数读取这个新报<br>文</p>
<h4 id="打包报文"><a href="#打包报文" class="headerlink" title="打包报文"></a>打包报文</h4><p>配置好 CAN 接口后，我们就可以复用它来发送数据了。利用 CAN 发送数据，要先把数据打包成完整的 CAN 报文格式。</p>
<p>void CAN_SetMsg(void)<br>{<br>    //TxMessage.StdId=0x00;<br>    TxMessage.ExtId=0x1314; //使用的扩展 ID<br>    TxMessage.IDE=CAN_ID_EXT; //扩展模式<br>    TxMessage.RTR=CAN_RTR_DATA; //发送的是数据<br>    TxMessage.DLC=2; //数据长度为 2 字节<br>    TxMessage.Data[0]=0xAB;<br>    TxMessage.Data[1]=0xCD;<br>}</p>
<p>函数使用的结构体变量 TxMessage 在 main 文件以全局变量的形式定义，结构体变量 TxMessage 和 RxMessage.<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CanTxMsg TxMessage; <span class="comment">// 发送缓冲区</span></span><br><span class="line">CanRxMsg RxMessage; <span class="comment">// 接收缓冲区</span></span><br></pre></td></tr></table></figure></p>
<p>TxMessage 的类型为 CanTxMsg，而接收报文时，我们使用 CanRxMsg 类型。它们都是由库文件定义的结构体类型。</p>
<p><strong>报文打包函数</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void CAN_SetMsg(void)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//TxMessage.StdId=0x00;</span></span><br><span class="line">	TxMessage.ExtId=<span class="number">0x1314</span>; <span class="comment">//使用的扩展 ID</span></span><br><span class="line">	TxMessage.IDE=CAN_ID_EXT; <span class="comment">//扩展模式</span></span><br><span class="line">	TxMessage.RTR=CAN_RTR_DATA; <span class="comment">//发送的是数据</span></span><br><span class="line">	TxMessage.DLC=<span class="number">2</span>; <span class="comment">//数据长度为 2 字节</span></span><br><span class="line">	TxMessage.Data[<span class="number">0</span>]=<span class="number">0xDC</span>;</span><br><span class="line">	TxMessage.Data[<span class="number">1</span>]=<span class="number">0xBA</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>接收报文结构体 CanRxMsg</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> StdId; <span class="comment">/* 接收报文的标准 ID */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> ExtId; <span class="comment">/* 接收报文的扩展 ID */</span></span><br><span class="line">	<span class="keyword">uint8_t</span> IDE; <span class="comment">/* 报文的 IDE 位 */</span></span><br><span class="line">	<span class="keyword">uint8_t</span> RTR; <span class="comment">/* 报文的 RTR 位 */</span></span><br><span class="line">	<span class="keyword">uint8_t</span> DLC; <span class="comment">/* 报文的 DLC 段 */</span></span><br><span class="line">	<span class="keyword">uint8_t</span> Data[<span class="number">8</span>]; <span class="comment">/* 报文的数据段 */</span></span><br><span class="line">	<span class="keyword">uint8_t</span> FMI; <span class="comment">/* 过滤器匹配序号 */</span></span><br><span class="line"></span><br><span class="line">&#125; CanRxMsg;</span><br></pre></td></tr></table></figure></p>
<h4 id="接收报文、编写中断服务函数"><a href="#接收报文、编写中断服务函数" class="headerlink" title="接收报文、编写中断服务函数"></a>接收报文、编写中断服务函数</h4><p>从机中断服务函数<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void USB_LP_CAN1_RX0_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">	CAN_Receive(CAN1, CAN_FIFO0, &amp;RxMessage);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 比较是否是发送的数据和 ID */</span></span><br><span class="line"></span><br><span class="line">	if ((RxMessage.ExtId==<span class="number">0x1314</span>) &amp;&amp; (RxMessage.IDE==CAN_ID_EXT)&amp;&amp; (RxMessage.DLC==<span class="number">2</span>) \</span><br><span class="line">		 &amp;&amp;((RxMessage.Data[<span class="number">1</span>]|RxMessage.Data[<span class="number">0</span>]&lt;&lt;<span class="number">8</span>)==<span class="number">0xABCD</span>)) </span><br><span class="line">	&#123;</span><br><span class="line">		flag = <span class="number">0</span>; <span class="comment">//接收成功</span></span><br><span class="line">	&#125; </span><br><span class="line">	else </span><br><span class="line">	&#123;</span><br><span class="line">	     flag = <span class="number">0xff</span>; <span class="comment">//接收失败</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在中断服务函数中，我们调用了库函数 CAN_Receive() 把 FIFO0 的报文读取到 main<br>文件的 CanRxMsg 类型全局变量 RxMessage 中。</p>
<p>使用 CAN_Receive() 函数接收了报文后，我们使用 if 语句判断接收到的报文的 ID 信息、IDE 位、DLC 位及数据段是否等于 0xABCD，若接收到的报文与我们主机预定发送的报文一样，则把 fl ag 位置“0”，退出中断服务函数。</p>
</div><div class="tags"><a href="/tags/通信协议/">通信协议</a></div><div class="post-nav"><a class="pre" href="/2018/09/29/Algorithm/Data_Structre_Algorithm/03、复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？/">03、复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？</a><a class="next" href="/2018/09/25/QRS/Wireless_Protocol/蓝牙4.0BLE协议栈技术入门/"></a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android学习笔记/">Android学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CC2540/">CC2540</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C语言学习/">C语言学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/FreeRTOS/">FreeRTOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Numpy学习笔记/">Numpy学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/PyQt5快速开发与实战/">PyQt5快速开发与实战</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python学习笔记/">Python学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/STM32学习笔记/">STM32学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/单片机/">单片机</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/嵌入式开发学习笔记/">嵌入式开发学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法之美学习笔记/">数据结构与算法之美学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法之美学习笔记s/">数据结构与算法之美学习笔记s</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/汽车总线/">汽车总线</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/汽车电子学习笔记/">汽车电子学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/汽车电子开发学习笔记/">汽车电子开发学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/硬件学习笔记/">硬件学习笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Python-Numpy/" style="font-size: 15px;">Python Numpy</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/锂电池/" style="font-size: 15px;">锂电池</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Python3/" style="font-size: 15px;">Python3</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/C51/" style="font-size: 15px;">C51</a> <a href="/tags/STM32项目/" style="font-size: 15px;">STM32项目</a> <a href="/tags/STM32基础/" style="font-size: 15px;">STM32基础</a> <a href="/tags/汽车电子/" style="font-size: 15px;">汽车电子</a> <a href="/tags/硬件基础/" style="font-size: 15px;">硬件基础</a> <a href="/tags/嵌入式基础知识/" style="font-size: 15px;">嵌入式基础知识</a> <a href="/tags/PyQt5/" style="font-size: 15px;">PyQt5</a> <a href="/tags/嵌入式基础知识-硬件基础知识/" style="font-size: 15px;">嵌入式基础知识 硬件基础知识</a> <a href="/tags/嵌入式基础知识-通信协议/" style="font-size: 15px;">嵌入式基础知识 通信协议</a> <a href="/tags/通信协议/" style="font-size: 15px;">通信协议</a> <a href="/tags/嵌入式基础知识-通信协议/" style="font-size: 15px;">嵌入式基础知识, 通信协议</a> <a href="/tags/FreeRTOS/" style="font-size: 15px;">FreeRTOS</a> <a href="/tags/CC2540/" style="font-size: 15px;">CC2540</a> <a href="/tags/LIN/" style="font-size: 15px;">LIN</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/21/QRS/Car/LIN/LIN学习——诊断/">LIN学习——诊断</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/20/QRS/Car/LIN/LIN学习——LIN应用层/">QRS/Car/LIN/LIN学习——LIN应用层</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/20/QRS/Car/LIN/LIN学习——工作流/">LIN学习——工作流</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/19/QRS/Car/LIN/LIN学习——LIN描述文件/">QRS/Car/LIN/LIN学习——LIN描述文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/19/QRS/Car/LIN/LIN学习——API/">QRS/Car/LIN/LIN学习——API</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/14/QRS/Car/LIN/LIN入门书学习笔记/">LIN入门书学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/14/QRS/Car/LIN/LIN入门书 —— 信号处理、配置、识别、诊断/">LIN入门 信号处理、配置、识别、诊断</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/30/Algorithm/Data_Structre_Algorithm/04、复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度/">04、复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/30/MCU/Peripheral/STM32 摄像头OV7670/">04、复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/29/Algorithm/Data_Structre_Algorithm/02、如何抓住重点，系统高效地学习数据结构与算法？/">02、如何抓住重点，系统高效地学习数据结构与算法？</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">yphfree的学习笔记.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>