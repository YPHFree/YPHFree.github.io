<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>C语言嵌入式系统编程——软件架构篇 | yphfree的学习笔记</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">C语言嵌入式系统编程——软件架构篇</h1><a id="logo" href="/.">yphfree的学习笔记</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">C语言嵌入式系统编程——软件架构篇</h1><div class="post-meta">Apr 19, 2016<span> | </span><span class="category"><a href="/categories/嵌入式C-C-学习笔记/">嵌入式C/C++学习笔记</a></span></div><div class="post-content"><p>本篇介绍了嵌入式系统编程软件架构方面的知识，主要包括<strong>模块划分、多任务还是单任务选取、单任务程序典型架构、中断服务程序、硬件驱动模块设计</strong>等，从宏观上给出了一个嵌入式系统软件所包含的主要元素。</p>
<h3 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h3><p>模块划分的”划”是规划的意思，意指怎样合理的将一个很大的软件划分为一系列功能独立的部分合作完成系统的需求。C语言作为一种结构化的程序设计语言，在模块的划分上主要依据功能（依功能进行划分在面向对象设计中成为一个错误，牛顿定律遇到了&gt;相对论），C 语言模块化程序设计需理解如下概念：</p>
<p><strong>（1） 模块即是一个.c 文件和一个.h 文件的结合，头文件(.h)中是对于该模块接口的声明；<br>（2） 某模块提供给其它模块调用的外部函数及数据需在.h 中文件中冠以 extern 关键字声明；<br>（3） 模块内的函数和全局变量需在.c 文件开头冠以 static 关键字声明；<br>（4）永远不要在.h文件中定义变量！定义变量和声明变量的区别在于定义会产生内存分配的操作，是汇编阶段的概念；而声明则只是告诉包含该声明的模块在连接阶段从其它模块寻找外部函数和变量。</strong></p>
<p>如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*module1.h*/</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>; <span class="comment">/* 在模块 1 的.h 文件中定义 int a */</span></span><br><span class="line"><span class="comment">/*module1 .c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"module1.h"</span> <span class="comment">/* 在模块 1 中包含模块 1 的.h 文件 */</span></span></span><br><span class="line"><span class="comment">/*module2 .c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"module1.h"</span> <span class="comment">/* 在模块 2 中包含模块 1 的.h 文件 */</span></span></span><br><span class="line"><span class="comment">/*module3 .c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"module1.h"</span> <span class="comment">/* 在模块 3 中包含模块 1 的.h 文件 */</span></span></span><br></pre></td></tr></table></figure></p>
<p>以上程序的结果是在模块 1、2、3 中都定义了整型变量 a，a 在不同的模块中对应不同的地址单元.</p>
<p>正确的做法是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*module1.h*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a; <span class="comment">/* 在模块 1 的.h 文件中声明 int a */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*module1 .c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"module1.h"</span> <span class="comment">/* 在模块 1 中包含模块 1 的.h 文件 */</span></span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>; <span class="comment">/* 在模块 1 的.c 文件中定义 int a */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*module2 .c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"module1.h"</span> <span class="comment">/* 在模块 2 中包含模块 1 的.h 文件 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*module3 .c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"module1.h"</span> <span class="comment">/* 在模块 3 中包含模块 1 的.h 文件 */</span></span></span><br></pre></td></tr></table></figure>
<p>这样如果模块 1、2、3 操作 a 的话，对应的是同一片内存单元。</p>
<p><strong>一个嵌入式系统通常包括两类模块：<br>（1）硬件驱动模块，一种特定硬件对应一个模块；<br>（2）软件功能模块，其模块的划分应满足低偶合、高内聚的要求.</strong></p>
<h3 id="多任务还是单任务"><a href="#多任务还是单任务" class="headerlink" title="多任务还是单任务"></a>多任务还是单任务</h3><p><strong>所谓”单任务系统”是指该系统不能支持多任务并发操作，宏观串行地执行一个任务。而多任务系统则可以宏观并行（微观上可能串行）地”同时”执行多个任务。多任务的并发执行通常依赖于一个多任务操作系统（OS），多任务OS的核心是系统调度器，它使用任务控制块（TCB）来管理任务调度功能。TCB包括任务的当前状态、优先级、要等待的事件或资源、任务程序码的起始地址、初始堆栈指针等信息。调度器在任务被激活时，要用到这些信息。此外，TCB还被用来存放任务的”上下文”（context)。任务的上下文就是当一个执行中的任务被停止时，所要保存的所有信息。通常，上下文就是计算机当前的状态，也即各个寄存器的内容。当发生任务切换时，当前运行的任务的上下文被存入TCB，并将要被执行的任务的上下文从它的 TCB 中取出，放入各个寄存器中。</strong></p>
<h3 id="单任务程序典型架构"><a href="#单任务程序典型架构" class="headerlink" title="单任务程序典型架构"></a>单任务程序典型架构</h3><p>（1）从 CPU 复位时的指定地址开始执行；<br>（2）跳转至汇编代码 startup 处执行；<br>（3）跳转至用户主程序 main 执行，在 main 中完成：<br>  a.初试化各硬件设备；<br>  b.初始化各软件模块；<br>  c.进入死循环（无限循环），调用各模块的处理函数</p>
<p>用户主程序和各模块的处理函数都以 C 语言完成。用户主程序最后都进入了一个死循环，其首选方案是：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">while</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">有的程序员这样写：</span><br><span class="line"><span class="function"><span class="title">for</span><span class="params">(;;)</span></span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="中断服务程序"><a href="#中断服务程序" class="headerlink" title="中断服务程序"></a>中断服务程序</h3><p>中断是嵌入式系统中重要的组成部分，但是在标准 C 中不包含中断。许多编译开发商在标准 C 上增加了对中断的支持，提供新的关键字用于标示中断服务程序 (ISR)，类似于__interrupt、#program interrupt等。当一个函数被定义为ISR的时候，编译器会自动为该函数增加中断服务程序所需要的中断现场入栈和出栈代码。</p>
<p><strong>中断服务程序需要满足如下要求：<br>(1)不能返回值；<br>(2)不能向 ISR 传递参数；<br>(3) ISR 应该尽可能的短小精悍；<br>(4) printf(char * lpFormatString,…)函数会带来重入和性能问题，不能在 ISR 中采用。<br>在某项目的开发中，我们设计了一个队列，在中断服务程序中，只是将中断类型添加入该队列中，在主程序的死循环中不断扫描中断队列是否有中断，有则取出队列中的第一个中断类型，进行相应处理。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 存放中断的队列 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagIntQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> intType; <span class="comment">/* 中断类型 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagIntQueue</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;IntQueue;</span><br><span class="line"></span><br><span class="line">IntQueue lpIntQueueHead;</span><br><span class="line"></span><br><span class="line">__<span class="function">interrupt <span class="title">ISRexample</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> intType;</span><br><span class="line"></span><br><span class="line">    intType = GetSystemType();</span><br><span class="line"></span><br><span class="line">    QueueAddTail(lpIntQueueHead, intType)；<span class="comment">/* 在队列尾加入新的中断 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主程序循环中判断是否有中断：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">While</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">If</span>( !IsIntQueueEmpty() )</span><br><span class="line">    &#123;</span><br><span class="line">        intType = GetFirstInt();</span><br><span class="line">        <span class="keyword">switch</span>(intType) <span class="comment">/* 是不是很象 WIN32 程序的消息解析函数? */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 对，我们的中断类型解析很类似于消息驱动 */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> xxx: <span class="comment">/* 我们称其为"中断驱动"吧？ */</span></span><br><span class="line">            	…</span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> xxx:</span><br><span class="line">           		…</span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">            …</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>按上述方法设计的中断服务程序很小，实际的工作都交由主程序执行了。</p>
<h3 id="硬件驱动模块"><a href="#硬件驱动模块" class="headerlink" title="硬件驱动模块"></a>硬件驱动模块</h3><p><strong>一个硬件驱动模块通常应包括如下函数：<br>   （1）中断服务程序 ISR<br>   （2）硬件初始化</strong></p>
<pre><code>a.修改寄存器，设置硬件参数（如 UART 应设置其波特率，AD/DA 设备应设置其采样速率等）；
b.将中断服务程序入口地址写入中断向量表：

<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置中断向量表 */</span></span><br><span class="line"><span class="attr">m_myPtr</span> = make_far_pointer(<span class="number">0</span>l); <span class="comment">/* 返回 void far 型指针 void far * */</span></span><br><span class="line">m_myPtr += ITYPE_UART; <span class="comment">/* ITYPE_UART： uart 中断服务程序 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 相对于中断向量表首地址的偏移 */</span></span><br><span class="line">*<span class="attr">m_myPtr</span> = &amp;UART _Isr; <span class="comment">/* UART _Isr：UART 的中断服务程序 */</span></span><br></pre></td></tr></table></figure>
</code></pre><p><strong>（3）设置 CPU 针对该硬件的控制线</strong><br>    a.如果控制线可作 PIO（可编程 I/O）和控制信号用，则设置 CPU 内部对应寄存器使其作为控制信号；<br>    b.设置 CPU 内部的针对该设备的中断屏蔽位，设置中断方式（电平触发还是边缘触发）。</p>
<p><strong>（4）提供一系列针对该设备的操作接口函数。</strong><br>    例如，对于LCD，其驱动模块应提供绘制像素、画线、绘制矩阵、显<br>    示字符点阵等函数；而对于实时钟，其驱动模块则需提供获取时间、设置时间等函数。    </p>
<h3 id="C-的面向对象化"><a href="#C-的面向对象化" class="headerlink" title="C 的面向对象化"></a>C 的面向对象化</h3><p>在面向对象的语言里面，出现了类的概念。类是对特定数据的特定操作的集合体。类包含了两个范畴：数据和操作。而 C 语言中的 struct 仅仅是数据的集合，我们可以利用函数指针将 struct 模拟为一个包含数据和操作的”类”。</p>
<p>下面的 C程序模拟了一个最简单的”类”：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> C_Class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C_Class struct</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">C_Class A</span><br><span class="line">&#123;</span><br><span class="line">    C_Class A *A_this; <span class="comment">/* this 指针 */</span></span><br><span class="line">    <span class="keyword">void</span> (*Foo)(C_Class A *A_this); <span class="comment">/* 行为：函数指针 */</span></span><br><span class="line">    <span class="keyword">int</span> a; <span class="comment">/* 数据 */</span></span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们可以利用 C 语言模拟出面向对象的三个特性：封装、继承和多态，但是更多的时候，我们只是需要将数据与行为<br>封装以解决软件结构混乱的问题。C 模拟面向对象思想的目的不在于模拟行为本身，而在于解决某些情况下使用 C 语言编程时程序整体框架结构分散、数据和函数脱节的问题。我们在后续章节会看到这样的例子。    </p>
</div><div class="tags"><a href="/tags/C/">C</a></div><div class="post-nav"><a class="pre" href="/2016/04/19/C/C语言嵌入式系统编程/">嵌入式C语言常用知识点总结</a><a class="next" href="/2016/04/18/C/详解C中静态变量 static/">详解C中volatile关键字</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C语言学习/">C语言学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/FreeRTOS/">FreeRTOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Numpy学习笔记/">Numpy学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/PyQt5快速开发与实战/">PyQt5快速开发与实战</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python学习笔记/">Python学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/STM32学习笔记/">STM32学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/单片机/">单片机</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/嵌入式C-C-学习笔记/">嵌入式C/C++学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/嵌入式开发学习笔记/">嵌入式开发学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/硬件学习笔记/">硬件学习笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/嵌入式软件/" style="font-size: 15px;">嵌入式软件</a> <a href="/tags/C/" style="font-size: 15px;">C</a> <a href="/tags/硬件基础/" style="font-size: 15px;">硬件基础</a> <a href="/tags/锂电池/" style="font-size: 15px;">锂电池</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/通信协议/" style="font-size: 15px;">通信协议</a> <a href="/tags/C-算法/" style="font-size: 15px;">C 算法</a> <a href="/tags/嵌入式项目/" style="font-size: 15px;">嵌入式项目</a> <a href="/tags/Python3/" style="font-size: 15px;">Python3</a> <a href="/tags/STM32基础/" style="font-size: 15px;">STM32基础</a> <a href="/tags/C51/" style="font-size: 15px;">C51</a> <a href="/tags/PyQt5/" style="font-size: 15px;">PyQt5</a> <a href="/tags/Python-Numpy/" style="font-size: 15px;">Python Numpy</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/04/10/Python/numpy/Numpy学习笔记/">Numpy学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/18/RTOS/FreeRTOS/FreeRTOS 列表和列表项/">FreeRTOS 列表和列表项</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/16/Python/Python 3 正则表达式/">Python3基础  正则表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/15/RTOS/FreeRTOS/FreeRTOS 任务相关API函数/">FreeRTOS任务相关API函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/24/UAV/无人机基础知识总结/">无人机基础知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/17/HardWare/TI锂离子电池组管理器-电量监测计BQ40Z50-R1学习笔记/">TI锂离子电池组管理器 电量监测计BQ40Z50-R1学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/17/HardWare/TI单节电量计基本介绍/">TI单节电量计基本介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/14/HardWare/锂电池充电电压与充电电流设定/">锂电池充电电压与充电电流设定</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/13/HardWare/锂电池充电原理/">锂电池充电原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/10/Python/PyQt5/PyQt中MainWindow, QWidget以及Dialog的区别和选择/">PyQt中MainWindow, QWidget以及Dialog的区别和选择</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">yphfree的学习笔记.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>