<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>02、如何抓住重点，系统高效地学习数据结构与算法？ | yphfree的学习笔记</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">02、如何抓住重点，系统高效地学习数据结构与算法？</h1><a id="logo" href="/.">yphfree的学习笔记</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">02、如何抓住重点，系统高效地学习数据结构与算法？</h1><div class="post-meta">Sep 29, 2017<span> | </span><span class="category"><a href="/categories/数据结构与算法之美学习笔记/">数据结构与算法之美学习笔记</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是复杂度分析？"><span class="toc-number">1.</span> <span class="toc-text">什么是复杂度分析？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间复杂度分析"><span class="toc-number">2.</span> <span class="toc-text">时间复杂度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#只关注循环执行次数最多的一行代码"><span class="toc-number">2.1.</span> <span class="toc-text">只关注循环执行次数最多的一行代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加法法则：总复杂度等于量级最大的那段代码的复杂度"><span class="toc-number">2.2.</span> <span class="toc-text">加法法则：总复杂度等于量级最大的那段代码的复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><span class="toc-number">2.3.</span> <span class="toc-text">乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#几种常见时间复杂度实例分析"><span class="toc-number">3.</span> <span class="toc-text">几种常见时间复杂度实例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#O-1"><span class="toc-number">3.1.</span> <span class="toc-text">O(1)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-logn-、O-nlogn"><span class="toc-number">3.2.</span> <span class="toc-text">O(logn)、O(nlogn)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-m-n-、O-m-n"><span class="toc-number">3.3.</span> <span class="toc-text">O(m + n)、O(m * n)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#空间复杂度"><span class="toc-number">3.4.</span> <span class="toc-text">空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内容小结"><span class="toc-number">4.</span> <span class="toc-text">内容小结</span></a></li></ol></div></div><div class="post-content"><p>数据结构和算法本身解决的是</p>
<h3 id="什么是复杂度分析？"><a href="#什么是复杂度分析？" class="headerlink" title="什么是复杂度分析？"></a>什么是复杂度分析？</h3><p>1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。<br>2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。<br>3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。<br>4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。</p>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。</p>
<p><strong>特点</strong></p>
<p>以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。</p>
<p><strong>复杂度分析法则</strong><br>1）单段代码看高频：比如循环。<br>2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。<br>3）嵌套代码求乘积：比如递归、多重循环等<br>4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。</p>
<h4 id="只关注循环执行次数最多的一行代码"><a href="#只关注循环执行次数最多的一行代码" class="headerlink" title="只关注循环执行次数最多的一行代码"></a>只关注循环执行次数最多的一行代码</h4><p>大O这种复杂度表示方法只是一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。这段核心代码执行次数的n的量级，就是整段要分析代码的时间复杂度。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cal(<span class="keyword">int</span> n) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">sum</span> = <span class="keyword">sum</span> + i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">sum</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、3行代码都是常量级的执行时间，与n的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第4、5行代码，所以这块代码要重点分析。前面说过，这两行代码被执行了n次，所以总的时间复杂度就是O(n)。</p>
<h4 id="加法法则：总复杂度等于量级最大的那段代码的复杂度"><a href="#加法法则：总复杂度等于量级最大的那段代码的复杂度" class="headerlink" title="加法法则：总复杂度等于量级最大的那段代码的复杂度"></a>加法法则：总复杂度等于量级最大的那段代码的复杂度</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">   int sum_1 = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">   int p = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   for (<span class="comment">; p &lt; 100; ++p) &#123;</span></span><br><span class="line">     sum_1 = sum_1 + p<span class="comment">;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   int sum_2 = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">   int q = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   for (<span class="comment">; q &lt; n; ++q) &#123;</span></span><br><span class="line">     sum_2 = sum_2 + q<span class="comment">;</span></span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   int sum_3 = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">   int i = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   int <span class="keyword">j </span>= <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   for (<span class="comment">; i &lt;= n; ++i) &#123;</span></span><br><span class="line">     <span class="keyword">j </span>= <span class="number">1</span><span class="comment">; </span></span><br><span class="line">     for (<span class="comment">; j &lt;= n; ++j) &#123;</span></span><br><span class="line">       sum_3 = sum_3 +  i * <span class="keyword">j;</span></span><br><span class="line"><span class="keyword"> </span>    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   return sum_1 + sum_2 + sum_3<span class="comment">;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>综合三段代码的时间复杂度，我们取其中最大的量级。所以，整段代码的时间复杂度就为O(n²)。也就是说：<strong>总的时间复杂度就等于量级最大的那段代码的时间复杂度。</strong>那我们将这个规律抽象成公式就是：</p>
<p>如果 T1(n)=O(f(n))，T2(n)=O(g(n)),<br>那么T(n)=T1(n)+T2(n)=max(Of(n)，Og(n))=O(max(f(n)，g(n)));     </p>
<h4 id="乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><a href="#乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积" class="headerlink" title="乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"></a>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</h4><p>乘法法则的公式：</p>
<p>如果T1(n)=O(f(n))，T2(n)=O(g(n))；那么T(n)=T1(n) <em> T2(n)=O(f(n)) </em> O(g(n))=O(f(n) * g(n));</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> cal(<span class="built_in">int</span> <span class="built_in">n</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    for (; i &lt; <span class="built_in">n</span>; ++i) &#123;</span><br><span class="line"></span><br><span class="line">    ret = ret + f(i);</span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> f(<span class="built_in">int</span> <span class="built_in">n</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  for (; i &lt; <span class="built_in">n</span>; ++i) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">sum</span> = <span class="built_in">sum</span> + i;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  return <span class="built_in">sum</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>单独看cal()函数。假设f()只是一个普通的操作，那第4～6行的时间复杂度就是，T1(n)=O(n)。但f()函数本身不是一个简单的操作，它的时间复杂度是T2(n)=O(n),所以,整个cal()函数的时间复杂度就是,Tn=T1(n)<em>T2(n)=O(n</em>n)=O(n²)。</p>
<p><img src="https://github.com/YPHFree/yphfree.github.io/blob/master/Algorithm/Data_Structre_Algorithm/image/fuzadu.jpeg" alt="image"></p>
<p>对于刚罗列的复杂度量级，我们可以粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2n) 和 O(n!)。</p>
<p>我们把时间复杂度为非多项式量级的算法问题叫作NP（Non-Deterministic Polynomial，非确定多项式）问题。</p>
<p>当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。</p>
<h3 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="headerlink" title="几种常见时间复杂度实例分析"></a>几种常见时间复杂度实例分析</h3><p>复杂度量级，我们可以粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2^n)和O(n!)。常见的多项式时间复杂度如下：</p>
<h4 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h4><p>首先你必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int i</span> = 8;</span><br><span class="line"><span class="attribute">int j</span> = 6;</span><br><span class="line"><span class="attribute">int sum</span> = i + j;</span><br></pre></td></tr></table></figure></p>
<p><strong>只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作   O(1)<br>。或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</strong></p>
<h4 id="O-logn-、O-nlogn"><a href="#O-logn-、O-nlogn" class="headerlink" title="O(logn)、O(nlogn)"></a>O(logn)、O(nlogn)</h4><p>对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。我通过一个例子来说明一下。<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">i</span>=<span class="number">1</span><span class="comment">;</span></span><br><span class="line">while (i &lt;= n)  &#123;</span><br><span class="line"></span><br><span class="line">    i = i * <span class="number">2</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据我们前面讲的复杂度分析方法，第三行代码是循环执行次数最多的。所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。</p>
<p>从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>^<span class="number">0</span>    <span class="number">2</span>^<span class="number">1</span>   <span class="number">2</span>^<span class="number">2</span>  ... <span class="number">2</span>^k    <span class="number">2</span>^x =n</span><br></pre></td></tr></table></figure></p>
<p>所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。通过 2x=n 求解 x 这个问题我们想高中应该就学过了，我就不多说了。x=log2n，所以，这段代码的时间复杂度就是O(log2n)。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">i</span>=<span class="number">1</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">while (i &lt;= n)  &#123;</span><br><span class="line"></span><br><span class="line">  i = i * <span class="number">3</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的时间复杂度为 O(log3n)。</p>
<p>实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。为什么呢？</p>
<p>我们知道，对数之间是可以互相转换的，log3n 就等于 log32 <em> log2n，所以 O(log3n) = O(C </em> log2n)，其中 C=log32 是一个常量。基于我们前面的一个理论：<strong>在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。</strong>所以，O(log2n) 就等于 O(log3n)<br>。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。</p>
<p>如果你理解了我前面讲的 O(logn)，那 O(nlogn) 就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。</p>
<h4 id="O-m-n-、O-m-n"><a href="#O-m-n-、O-m-n" class="headerlink" title="O(m + n)、O(m * n)"></a>O(m + n)、O(m * n)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 = sum_1 + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">    sum_2 = sum_2 + j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。</p>
<p>针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m) <em> T2(n) = O(f(m) </em> f(n))。</p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span> void <span class="keyword">print</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line"><span class="symbol">2 </span>     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="symbol">3 </span>     <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="symbol">4 </span>     <span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</span><br><span class="line"><span class="symbol">5 </span>         a[i] = i * i;</span><br><span class="line"><span class="symbol">6 </span>     &#125;</span><br><span class="line"></span><br><span class="line"><span class="symbol">7 </span> <span class="keyword">for</span> (i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="symbol">8 </span>     <span class="keyword">print</span> <span class="keyword">out</span> a[i]</span><br><span class="line"><span class="symbol">9 </span>     &#125;</span><br><span class="line"><span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure>
<p>跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。</p>
<p>我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。所以，对于空间复杂度，掌握刚我说的这些内容已经足够了。</p>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )，几乎所有的数据结构和算法的复杂度都跑不出这几个。</p>
<p>版权归极客时间：<a href="https://time.geekbang.org/column/126" target="_blank" rel="noopener">https://time.geekbang.org/column/126</a></p>
</div><div class="tags"><a href="/tags/算法/">算法</a></div><div class="post-nav"><a class="pre" href="/2017/10/02/RTOS/FreeRTOS/FreeRTOS 信号量/">FreeRTOS 信号量</a><a class="next" href="/2017/09/29/Algorithm/Data_Structre_Algorithm/02、如何抓住重点，系统高效地学习数据结构与算法？/">02、如何抓住重点，系统高效地学习数据结构与算法？</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android学习笔记/">Android学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CC2540/">CC2540</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C语言学习/">C语言学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/FreeRTOS/">FreeRTOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Numpy学习笔记/">Numpy学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/PyQt5快速开发与实战/">PyQt5快速开发与实战</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python学习笔记/">Python学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/STM32学习笔记/">STM32学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/单片机/">单片机</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/嵌入式开发学习笔记/">嵌入式开发学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法之美/">数据结构与算法之美</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法之美学习笔记/">数据结构与算法之美学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/硬件学习笔记/">硬件学习笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Python-Numpy/" style="font-size: 15px;">Python Numpy</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/硬件基础/" style="font-size: 15px;">硬件基础</a> <a href="/tags/锂电池/" style="font-size: 15px;">锂电池</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Python3/" style="font-size: 15px;">Python3</a> <a href="/tags/STM32项目/" style="font-size: 15px;">STM32项目</a> <a href="/tags/STM32基础/" style="font-size: 15px;">STM32基础</a> <a href="/tags/PyQt5/" style="font-size: 15px;">PyQt5</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/嵌入式基础知识-硬件基础知识/" style="font-size: 15px;">嵌入式基础知识 硬件基础知识</a> <a href="/tags/嵌入式基础知识/" style="font-size: 15px;">嵌入式基础知识</a> <a href="/tags/通信协议/" style="font-size: 15px;">通信协议</a> <a href="/tags/嵌入式基础知识-通信协议/" style="font-size: 15px;">嵌入式基础知识 通信协议</a> <a href="/tags/嵌入式基础知识-通信协议/" style="font-size: 15px;">嵌入式基础知识, 通信协议</a> <a href="/tags/FreeRTOS/" style="font-size: 15px;">FreeRTOS</a> <a href="/tags/CC2540/" style="font-size: 15px;">CC2540</a> <a href="/tags/C51/" style="font-size: 15px;">C51</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/09/25/QRS/Wireless_Protocol/蓝牙4.0BLE协议栈技术入门/">QRS/Wireless_Protocol/蓝牙4.0BLE协议栈技术入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/25/QRS/Wireless_Protocol/蓝牙4.0BLE应用实例/">QRS/Wireless_Protocol/蓝牙4.0BLE应用实例</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/13/Android/Android学习笔记6——文件存储/">Android学习笔记6——文件存储</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/10/Python/numpy/Numpy学习笔记/">Numpy学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/16/Python/Python 3 正则表达式/">Python3基础  正则表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/16/Python/Python 网络编程/">Python3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/24/UAV/无人机基础知识总结/">无人机基础知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/20/RTOS/FreeRTOS/FreeRTOS 内存管理/">FreeRTOS 内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/17/HardWare/TI锂离子电池组管理器-电量监测计BQ40Z50-R1学习笔记/">TI锂离子电池组管理器 电量监测计BQ40Z50-R1学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/17/HardWare/TI单节电量计基本介绍/">TI单节电量计基本介绍</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">yphfree的学习笔记.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>